#!/usr/bin/env python3
# Energy-aware eBPF monitor (aligned output, avg syscalls only at start/end)
from bcc import BPF
import psutil, time, datetime, os, csv, subprocess

# ===================== eBPF Program =====================
bpf_text = r"""
BPF_HASH(sys_cnt, u32, u64);
BPF_HASH(ctx_cnt, u32, u64);
BPF_HASH(pkt_cnt, u32, u64);

TRACEPOINT_PROBE(raw_syscalls, sys_enter) {
    u32 key = 0;
    u64 one = 1;
    u64 *val = sys_cnt.lookup(&key);
    if (val) { (*val) += 1; } else { sys_cnt.update(&key, &one); }
    return 0;
}

TRACEPOINT_PROBE(sched, sched_switch) {
    u32 key = 0;
    u64 one = 1;
    u64 *val = ctx_cnt.lookup(&key);
    if (val) { (*val) += 1; } else { ctx_cnt.update(&key, &one); }
    return 0;
}

TRACEPOINT_PROBE(net, netif_receive_skb) {
    u32 key = 0;
    u64 one = 1;
    u64 *val = pkt_cnt.lookup(&key);
    if (val) { (*val) += 1; } else { pkt_cnt.update(&key, &one); }
    return 0;
}
"""

# ===================== Traffic Control =====================
INTERFACE = "ens33"
MAX_BANDWIDTH = "1000mbit"

def setup_htb_qdisc():
    commands = [
        f"tc qdisc del dev {INTERFACE} root 2>/dev/null || true",
        f"tc qdisc add dev {INTERFACE} root handle 1: htb default 10",
        f"tc class add dev {INTERFACE} parent 1: classid 1:1 htb rate {MAX_BANDWIDTH}",
        f"tc class add dev {INTERFACE} parent 1:1 classid 1:10 htb rate {MAX_BANDWIDTH} ceil {MAX_BANDWIDTH} burst 15k",
        f"tc qdisc add dev {INTERFACE} parent 1:10 handle 10: sfq perturb 10"
    ]
    for cmd in commands:
        subprocess.run(cmd, shell=True, capture_output=True, text=True)

def cleanup_tc():
    subprocess.run(f"tc qdisc del dev {INTERFACE} root 2>/dev/null", shell=True)

def adjust_bandwidth(energy):
    if energy > 10.0: return "ðŸ”´ CRITICAL"
    elif energy > 8.0: return "ðŸŸ  HIGH"
    elif energy > 6.0: return "ðŸŸ¡ ELEVATED"
    else: return "ðŸŸ¢ NORMAL"

# ===================== Helper Functions =====================
def read_map(table):
    keys = list(table.keys())
    return int(table[keys[0]].value) if keys else 0

def get_cpu(): return psutil.cpu_percent(interval=1)
def energy(cpu, sys_s, ctx_s):
    return round((cpu * 0.4) + (sys_s * 0.00005) + (ctx_s * 0.0002), 2)

# ===================== Main =====================
CSV_FILE = "system_monitor_log.csv"

print("Press Cntrl+c to stop")


setup_htb_qdisc()
b = BPF(text=bpf_text)

# initialize CSV
with open(CSV_FILE, "w", newline="") as f:
    writer = csv.writer(f)
    writer.writerow(["timestamp", "status", "cpu", "packets", "syscalls", "ctx", "energy", "syscalls_avg"])

time.sleep(0.3)
prev_sys = read_map(b["sys_cnt"])
prev_ctx = read_map(b["ctx_cnt"])
prev_pkt = read_map(b["pkt_cnt"])

syscall_samples = []

try:
    while True:
        cpu = get_cpu()
        total_sys = read_map(b["sys_cnt"])
        total_ctx = read_map(b["ctx_cnt"])
        total_pkt = read_map(b["pkt_cnt"])

        delta_sys = total_sys - prev_sys
        delta_ctx = total_ctx - prev_ctx
        delta_pkt = total_pkt - prev_pkt

        syscall_samples.append(delta_sys)

        E = energy(cpu, delta_sys, delta_ctx)
        status = adjust_bandwidth(E)
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        print(
            f"[{timestamp}] {status:10} | CPU:{cpu:5.1f}% | Pkt/s:{delta_pkt:5} | Sys/s:{delta_sys:5} | "
            f"Ctx/s:{delta_ctx:5} | Energy:{E:6.2f}J"
        )

        with open(CSV_FILE, "a", newline="") as f:
            writer = csv.writer(f)
            writer.writerow([timestamp, status, cpu, delta_pkt, delta_sys, delta_ctx, E, 0])  # avg filled at exit

        prev_sys, prev_ctx, prev_pkt = total_sys, total_ctx, total_pkt
        time.sleep(1)

except KeyboardInterrupt:
    print("\nMonitoring stopped by user")
    if syscall_samples:
        avg_sys = round(sum(syscall_samples)/len(syscall_samples),2)
   

        # update last row in CSV with avg
        with open(CSV_FILE, "r") as f:
            rows = list(csv.reader(f))
        rows[-1][-1] = avg_sys
        with open(CSV_FILE, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerows(rows)

    cleanup_tc()
    print("Traffic control cleaned.\n")
